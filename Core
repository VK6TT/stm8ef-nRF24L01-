\ temporary dependencies

#require ]B!
#require ]C!

\ definitions *********************************************

\res MCU: nRF24L01

\ get nRF24L01+ bit masks
\res export BIT0 BIT1 BIT2 BIT3 BIT4 BIT5 BIT6 BIT7

\ get nRF24L01+ registers
\res export R.CONFIG R.SETUP_RETR R.RF_CH R.RF_SETUP
\res export R.STATUS R.RX_ADDR_P0 R.TX_ADDR R.RX_PW_P0

\ get nRF24L01+ commands
\res export R_RX_PAYLOAD W_TX_PAYLOAD W_ACK_PAYLOAD
\res export FLUSH_TX FLUSH_RX

NVM

\ bit and variable manipulation ***************************

: >LOW  ( c1 bitn ---- c2 )  \ set bitn low
   NOT AND
   ;

: >HIGH  ( c1 bitn ---- c2 )  \ set bitn high
   OR
   ;

\ talk to nRF24L01+ ***************************************

: (nrf@!)  ( c1 ---- )
   _CSN.LOW SPI  DROP
   ;

: nRF@n  ( c2 c1 --- cN..C1 )  \ read c2 bytes
   (nrf@!)
   0 DO
      -1 SPI
   LOOP
   _CSN.High
   ;

: nRF@1  ( c1 --- c2 )  \ fetch the contents of register c1
   1 SWAP nRF@n
   ;

\ Config register operations

: nRF!_  ( c1 A1 --- c1 )  \ factored starting seq
   $20 OR
   (nrf@!) \ calling word must set _CSN high when finished sending data
   ;

: nRF!0  ( c1 --- )  \ send command c1
   nRF!_
   _CSN.HIGH
   ;

: nRF!n  ( cn....c1 a1 n --- )  \ write to nRF24 register A1 n bytes
   SWAP nRF!_ \ sends address to write to
   0 DO
      SPI DROP
   LOOP
   _CSN.HIGH
   ;

: nRF!1  ( c a -- )
   1 nRF!n
   ;

: nRF!5  ( c5....c1 a -- )
   5 nRF!n
   ;

: IRQ@AND  ( c1 ---- f1 )
   \ Get Interrupts then AND with c1
   R.STATUS _CSN.LOW SPI _CSN.HIGH AND   \ cant use nRF@1 since it toggles _CE
   ;

: TEST_INT  ( c1 --- f1 )
   DUP BIT4 AND IF ." Max retries cleared" CR -1 ELSE 0 THEN ( --- c1 f1 )
   OVER BIT5 AND IF ." Tx data sent" CR -1 ELSE 0 THEN OR
   SWAP BIT6 AND IF ." Rx data ready" CR -1 ELSE 0 THEN OR
   ;

: CLR_INT  ( -- )
   R.STATUS nRF@1
   TEST_INT IF
     $70  R.STATUS nRF!1 \ 0b01110000
   THEN
   ;

: RX_DR?  ( -- f )  BIT6 IRQ@AND ;

: TX_DS?  ( -- f )  BIT5 IRQ@AND ;

: MAX_RT?  ( -- f )  BIT4 IRQ@AND ;

: RX_P_NO  ( -- c )  $0E IRQ@AND ; \ 0b00001110

: TX_Full?  ( -- f )  BIT0 IRQ@AND ;


\ lets setup nrf24L01+ how we want ************************

: SetAddress  ( -- )  \ LSB first
   $E7 $D6 $C5 $B4 $A3 R.RX_ADDR_P0  nRF!5
   $E7 $D6 $C5 $B4 $A3 R.TX_ADDR     nRF!5
   ;

: SetPL_width  ( c -- )  \ set bytes in rx payload
   R.RX_PW_P0  nRF!1
   ;

: R@Config  ( -- c1 )  \ fetch config reg
   R.CONFIG  nRF@1
   ;

: R!Config  ( c1 -- )  \ write C1 to config reg
   R.CONFIG  nRF!1
   ;

: TX.PWR-18  ( -- )  \ SEt to -18dBm output and 250kbps
   [ $0 BIT5 >HIGH ] LITERAL R.RF_SETUP nRF!1
   ;

: SetRetry  ( -- )  \ ARD: retransmit delay, ARC: retries
   ( ARD: 8*250us, ARC: 15* ) $8F R.SETUP_RETR nRF!1
   ;

: myChannel  ( -- ) \ set channel (fix, for now)
  $70 R.RF_CH nRF!1
  ;

: >Standby1  ( -- )  \ enter Standby state
   _CE.LOW   2 ms
   R@CONFIG
   [ BIT1 ( PWR_UP ) BIT2 ( CRC0 ) OR ] LITERAL >HIGH
   R!CONFIG
   ;

: PWR.Dn  ( -- )
   _CE.LOW R@Config  BIT1 >LOW R!Config
   ;

: FlushRx  ( -- )
   FLUSH_RX nRF!0
   ;

: FlushTx  ( -- )
   FLUSH_TX nRF!0
   ;

: _CE.HD  ( -- )
   \ set CE high and pause
   _CE.HIGH   13 *10us
   ;

: Set.RX  ( -- )
   \ set as a receiver
   R@Config BIT0 >HIGH  R!CONFIG
   ;

: Set.TX  ( -- )  \  set as a transmitter
   R@Config BIT0 >LOW  R!CONFIG
   ;

: nRF24Init  ( -- )  \ stuff we must do after a reset or power on
   setup_pins    \ set up pins and SPI (RST)
   _CSN.HIGH 1 SPIon
   100 ms        \ delay after power-on reset (spec fig. 3)
   >Standby1
   SetAddress
   TX.PWR-18
   FlushRx FlushTx CLR_INT
   SetRetry
   myChannel
   ." Device reset" cr
   ;

: (RX)  ( -- )  \ setup as primary receiver
   nRF24Init      \ setup and go to Standby1
   P0_WIDTH SetPL_width   \ effectively enables Pipe0
   Set.RX         \ Will be a RX
   ;

: (TX)  ( -- )  \ setup as primary transmitter
   nRF24Init      \ setup and go to Standby1
   Set.TX         \ enter TX mode
   ;

: b>nRF ( a n CMD -- s )  \  copy n chars from a to payload register on nRF24
   _CSN.LOW SPI ( a n -- s ) >R
   0 DO
      DUP C@ SPI DROP 1+
   LOOP _CSN.HIGH
   ( a -- ) DROP R> ( -- s )
   ;

: nRF>b ( b c CMD -- s )
   \  copy count c bytes from payload register on nRF24 to buffer b
   \  return nRF24 STATUS s
   _CSN.LOW SPI ( a n s -- ) >R
   0 DO
      -1 SPI OVER C! 1+
   LOOP  _CSN.HIGH
   ( -- a ) DROP R> ( -- s )
   ;

: b>tx ( b c -- s )
   \  copy c bytes from buffer b to TX payload and send, return STATUS
   W_TX_PAYLOAD b>nRF
   _CE.HD _CE.LOW  \  10us minimum, using 130uS
   ;

: b>ack ( b c p -- s )
   \  copy c bytes payload from buffer b to p ACK pipe p, return STATUS
   W_ACK_PAYLOAD OR b>nrf
   ;

: rx>b ( b c -- s )
   \  copy c bytes payload to buffer b, return STATUS
   R_RX_PAYLOAD nrf>b
   ;

RAM
